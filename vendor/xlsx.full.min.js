(function(global){
  if (global.XLSX) {
    return;
  }
  const root = global;
  const decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8') : null;
  function toUint8Array(data){
    if (data == null) return new Uint8Array();
    if (data instanceof ArrayBuffer) return new Uint8Array(data);
    if (ArrayBuffer.isView(data)) return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    if (typeof data === 'string') {
      const arr = new Uint8Array(data.length);
      for (let i = 0; i < data.length; i++) arr[i] = data.charCodeAt(i) & 0xff;
      return arr;
    }
    throw new TypeError('Unsupported data type for XLSX.read stub');
  }
  function decodeToString(bytes){
    if (!bytes || !bytes.length) return '';
    if (bytes[0] === 0x50 && bytes[1] === 0x4b) {
      throw new Error('Binary XLSX files are not supported by the embedded stub.');
    }
    if (decoder) {
      try {
        return decoder.decode(bytes);
      } catch (err) {
        console.warn('Failed to decode buffer via TextDecoder', err);
      }
    }
    let out = '';
    for (let i = 0; i < bytes.length; i++) {
      out += String.fromCharCode(bytes[i]);
    }
    return out;
  }
  function splitLines(text){
    return text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
  }
  function detectDelimiter(sample){
    const comma = (sample.match(/,/g) || []).length;
    const tab = (sample.match(/\t/g) || []).length;
    if (tab > comma) return '\t';
    if (comma > 0) return ',';
    return ',';
  }
  function parseDelimited(text){
    const lines = splitLines(text).filter(line => line.length > 0);
    if (!lines.length) return [];
    const delimiter = detectDelimiter(lines[0]);
    return lines.map(line => {
      const cells = [];
      let current = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (char === '"') {
          if (inQuotes && line[i + 1] === '"') {
            current += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === delimiter && !inQuotes) {
          cells.push(current);
          current = '';
        } else {
          current += char;
        }
      }
      cells.push(current);
      return cells;
    });
  }
  function buildSheet(rows){
    const sheet = { __rows: rows.slice() };
    return sheet;
  }
  function sheetToJSON(sheet, options){
    const rows = Array.isArray(sheet && sheet.__rows) ? sheet.__rows : [];
    if (!rows.length) return [];
    const headers = rows[0];
    const list = [];
    for (let r = 1; r < rows.length; r++) {
      const row = rows[r];
      const obj = {};
      for (let c = 0; c < headers.length; c++) {
        const headerRaw = headers[c];
        const key = headerRaw != null && headerRaw !== '' ? String(headerRaw) : `COL${c + 1}`;
        let value = c < row.length ? row[c] : undefined;
        if ((value === undefined || value === null || value === '') && Object.prototype.hasOwnProperty.call(options || {}, 'defval')) {
          value = options.defval;
        }
        obj[key] = value;
      }
      list.push(obj);
    }
    return list;
  }
  function read(data){
    const bytes = toUint8Array(data);
    const text = decodeToString(bytes);
    const rows = parseDelimited(text);
    return {
      SheetNames: ['Sheet1'],
      Sheets: {
        Sheet1: buildSheet(rows)
      }
    };
  }
  const XLSX = {
    version: '0.0.0-stub',
    read,
    utils: {
      sheet_to_json: sheetToJSON
    }
  };
  root.XLSX = XLSX;
})(typeof window !== 'undefined' ? window : globalThis);
